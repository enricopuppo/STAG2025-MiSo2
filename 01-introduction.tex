% !TEX root = STAG25-MiSo2.tex

\section{Introduction}
\label{sec:introduction}
Robust geometric computation is a critical component of many applications, such as collision detection, minimum distance computation, element inversion, and Boolean operations \cite{something}. Although floating-point arithmetic is fast, it can easily generate inaccurate results that may lead to unpredictable, often catastrophic outcomes, especially in simulations \cite{something}. In contrast, exact computation, using methods like rational arithmetic or arbitrary precision floating-point arithmetic, is extremely slow and often impractical.
Moreover, such methods are exact only for algebraic operations. 

Interval arithmetic bridges this gap by providing a viable alternative. 
It offers a balance between performance and accuracy, giving conservative estimates of exact computations at a moderate speed penalty compared to standard floating-point arithmetic. In this model, all real values are represented as intervals bounded by floating-point numbers. Expressions on these intervals are computed in a way that guarantees the resulting interval will contain the true mathematical result.
While the width of an interval can grow during computation, it is crucial to minimize this growth to maintain precision. This is achieved through \emph{correctly rounded} operations, where each elementary operation returns the tightest possible floating-point interval that contains the exact result.
%More fundamentally, if elementary computations are not correctly rounded, the same expression %evaluated with the same sequence of operations
% may give different results on different architectures, or even on the same architecture once the underlying mathematical library is changed. 

The IEEE 754 standard prescribes correctly rounded results only for the algebraic operations and the square root; all other 
%transcendental
operations are just \emph{recommended} to be correctly rounded, but there is no guarantee, depending on their implementation.
%The CORE-MATH project \cite{core-math} provides correctly rounded implementations for all the most common transcendental operations. 
Consequently, nowadays no libraries exist that guarantee the creation of as-tight-as-possible intervals when the expressions involve this kind of operations.
See Section \ref{sec:related} for further discussion.

% TOLTA FRASE SEGUENTE, RIPETE LE PRIMA DELL'INTRO
%Since such a kind of expressions are useful in diverse graphics applications (e.g., non-linear element inversion, collision detection, Boolean operations), i
In this paper, we describe the design principles of our TIGHT library for interval arithmetic, which always produces as-tight-as-possible intervals, is faster than any existing library, and supports transcendental functions.
%
Our original contributions include:
\begin{enumerate}
\item We extend the NFG library \cite{nfg} -- which provides the most efficient implementation of interval arithmetic to date, but is limited to algebraic operations -- with transcendental operations, based on the CORE-MATH floating-point correctly rounded implementation \cite{Sibidanov2022}.
In Section \ref{sec:functions}, we discuss the challenges involved in extending transcendental operators to intervals while guaranteeing correct rounding. 
\item We integrate our library with the recent Domain Specific Language MiSo \cite{Sichetti2025} that supports the fast prototyping of non-linear constraint solving and optimization. 
Extension of the language with transcendental functions largely broadens its spectrum of applicability. 
\item We demonstrate the effectiveness and efficiency of our library by implementing surface-surface intersection between non-algebraic surfaces, and continuous collision detection between geometric primitives undergoing roto-translational motion.  We also compare our library against the Filib library \cite{filib}, achieving a faster performance.
\end{enumerate}


%THE REST IS FROM SIGGRAPH PAPER - PROBABLY OBSOLETE, MAYBE SOMETHING USEFUL FOR THE RELATED

%Non-linear constraint solving is fundamental to graphics and scientific computing, with applications ranging from collision detection and minimal distance computation to element inversion and Boolean operations. A vast literature addresses this topic (Section \ref{sec:related}). For example, \cite{RTR4,Akenine2024} summarize methods for static collision detection between proxies, referencing over 100 algorithms tailored to different primitive pairs and accuracy/efficiency trade-offs.
%Similar per-primitive-pair specialization is required for minimal distance queries and, likewise, each finite element (FE) type and order necessitates custom code for positive Jacobian checks.
%This complexity doubles when considering time-dependent scenarios.

%While real-time applications often restrict primitives to boxes due to limited computational resources, high-fidelity simulations may require conservative, high-accuracy predicates \cite{snyder92}.
%Testing the correctness and ensuring the efficient, accurate implementation of these algorithms is a major challenge \cite{Wang2021}. The difficulty of generalizing theoretical improvements across different cases hinders progress in this pervasive and crucial family of algorithms, essential to modern computing.

%In contrast to algorithm specialization, Snyder \cite{snyder92} proposed a general framework, based on interval analysis, for conservative solutions to high-order constrained optimization. This framework offers two algorithms: \solve, which finds all solutions to a non-linear constraint system, and \minimize, which finds the constrained global minimum of a function. For \solve, the conservative algorithm returns a region guaranteed to contain all solutions (if any), potentially including points near the feasible domain. For \minimize, it returns a value less than or equal to the true minimum and within a bounded distance of it. In both cases, this conservativeness accounts for numerical rounding errors.

%Although often considered slower than methods like Newton's minimization, recent work \cite{Wang2021,Chen2024} 
 %demonstrates the effectiveness and relative efficiency of this conservative approach, particularly when seeking guaranteed solutions. 

%Snyder's approach uses Natural Interval Extensions (NIE) to compute \emph{inclusion functions} (\cref{sub:inclusion}) that bound function ranges over domains, by composition of interval operators (\cref{app:interval}). Although general, NIE's convergence to the true range via domain decomposition can be slow. 
%For the common case of polynomials, tighter bounds are achievable via their Bézier representation \cite{Lengagne:2020,stahl_interval_1995,johnen2013}. 
%However, Bézier representation can be computationally expensive for polynomials with many terms. 

%We employ a hybrid approach, blending Bézier inclusion functions and NIE. Decomposing polynomial expressions into simpler forms (fewer variables or lower degree) allows us to construct a spectrum of inclusion functions that ranges from fully NIE-based (expanded expressions) to fully Bézier-based (collapsed expressions).
%Hybrid solutions can dramatically improve efficiency. For example, our hybrid solver for continuous collision detection between high-order polynomial patches is orders of magnitude faster than purely NIE-based and purely Bézier-based solutions (\cref{sec:results}).

%We developed MiSo on top of such a hybrid approach. MiSo is a Python-based domain-specific language (DSL) for the specification of \solve\ and \minimize\ problems. MiSo enables the user to quickly explore possible hybrid approaches by changing a few lines of code.
%From a simple specification, the MiSo compiler produces a numerically robust C++ solver for the given problem, automatically generating all the necessary representations of the functions involved, the related transformations required for domain subdivision, and the evaluation of inclusion functions.

%Domain decomposition and interval arithmetic are used to guarantee conservative results. Setting a compile-time flag switches to a faster, non-conservative computation mode based on standard floating-point arithmetic.
%A known limitation of subdivision-based methods is that they suffer from a curse of dimensionality; hence, our method may become impractical for problems in many dimensions. However, we show that we are able to achieve competitive performance for a number of fundamental geometric problems, especially those involving high-order geometry.

%We demonstrate competitive performance against hand-optimized code for key computer graphics problems, including linear and high-order continuous collision detection, and finite element validity checks.

%MiSo is available as an open-source project at \url{https://gitlab.com/fsichetti/miso}.

