% !TEX root = STAG25-MiSo2.tex

\section{Results and comparison}
\label{sec:results}
We evaluate our library in several scenarios. Furthermore, because Filib/Filib++ is the only library which is always correct when transcendental functions are involved \cite{tang2022}, we compare TIGHT with this representative of the state of the art.

All experiments were timed single-threaded on a server equipped with Intel Xeon Gold 6430 CPUs and 64GB of RAM.
The compiler used is GCC version 13.3.0 on Ubuntu.

\subsection{Benchmark comparison}
We start by comparing the execution times and average interval width of single functions in TIGHT and Filib++.
To compute the width, for each operation we select one or two singleton input intervals that lie inside the function domain, and compute the number of floating point values between the lower and upper ends of the computed interval (plus one); a width of 1 ULP (or 0, in the case of an exactly representable output) corresponds to a correctly rounded result.
To get timings, we call each function one million times; to prevent the compiler from optimizing calls, and to evaluate the timing on non-singleton intervals, we perturb the input interval at each iteration by enlarging it by an ULP on both sides, and sum the upper and lower bound of each result to a dummy accumulator.
Note that some operations are omitted for Filib++ as they are not supported in the library.

Estimated times for executing one interval operation with the two libraries are reported in Table \ref{table:benchmarks}. 
Times are in nanoseconds. 
Note that, for the simplest operations that cost about or even less than one nanosecond, estimates are not fully reliable and may change on different runs.  
The values reported in the table for those operations are averages over different runs. 
However, we consistently had at all runs faster times with TIGHT, for all those operations that are already supported in NFG.   
For the newly implemented transcendental functions, times are comparable, but sometimes they are slower with TIGHT.
This is the cost of all additional operations that we undergo to guarantee correct rounding, which is not guaranteed by Filib++.

The latter issue is evident by looking at the two rightmost columns in Table \ref{table:benchmarks}, which report the width of the resulting interval in ULPs (number of contiguous floating-point values), when the input consists of a singleton $[x,x]$.
While TIGHT always produces intervals with a width of either zero or one ULP, hence correctly rounded, Filib++ produces quite large intervals in many cases (it is still correctly rounded, but slower, for algebraic operations). 

\input{timetable}

\subsection{Comparison with Filib++ within MiSo}
To assess the practical effectiveness of our library, we integrate it into the software MiSo \cite{Sichetti2025}, which makes intensive use of interval arithmetic.
MiSo is a Python tool to generate interval-based C++ solvers with correctness guarantees, which uses NFG for its fast interval arithmetic, albeit with no support for non-algebraic operations.
Since MiSo's architecture allows for easily switching the numeric backend, we were able to perform a side-by-side comparison of our library and Filib++ for several problems, while extending the software's support to transcendental operators.

The problems presented in the following involve heavy use of trigonometric functions that, as outlined above, are more expensive to compute in TIGHT than in Filib++.
However, as we shall see, TIGHT's result in faster solution times overall, thanks to faster handling of basic arithmetic and its smaller intervals.

\subsubsection{CCD along non-algebraic trajectories}
\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{fig/spiral.png}
	\caption{Test problem: CCD of a triangle moving rigidly along a screw trajectory, and another deforming triangle. The triangle on top rotates and moves along an axis until the two primitives come into contact.}
	\label{fig:tori}
\end{figure}
We consider the classical problem of continuous collision detection (CCD): given two primitives in space with some prescribed trajectory, we seek the first time in $[0,1]$ for which the primitives first come into contact, and call it $t^*$.
This type of test is essential in the simulation field to guarantee that physical objects do not interpenetrate.
In practice, finding the exact value of $t^*$ may be infeasible and often unnecessary. With interval methods, we instead seek an interval $T^*$ that is guaranteed to contain $t^*$ and is smaller than a user-specified precision $\delta>0$.
Then the lower bound of $T^*$ tells us a moment in time until which we can safely move the objects without collisions, and the upper bound gives a moment when a collision has surely happened already.
The difficulty of the query depends on the type of primitives, the type of trajectory, and the precision required.

Within MiSo, this is formulated as a \textsc{Minimize} problem, that is, a constrained global optimization \cite{Sichetti2025}.
In this case the optimization variables are $\{\mathbf{u}, \mathbf{v}, t\}$, where $\mathbf{u}=(u_0, u_1)$ and $\mathbf{v}=(v_0, v_1)$ are the parametric coordinates of the two primitives, and $t$ is time;
the constraints are the domain constraints $(u_0,u_1,v_0,v_1,t)\in[0,1]^5, u_0+u_1\leq1, v_0+v_1\leq1$ (which are all implicit in MiSo), and the collision constraint $d(x,y)<\epsilon$ with a small but positive $\epsilon$ -- i.e., we only consider pairs of points for which collision happens.
The objective function is $t$ -- i.e., we want to find the collision that happens earliest.

In our test, we consider two moving linear (i.e., flat) triangles, where one is linearly deforming (i.e., each vertex follows a linear trajectory independent of the others), while the other vertex is undergoing a rigid roto-translation, following a spiral motion.
More precisely, the center of the second triangle follows the spiral, and its normal remains aligned with the spiral's tangent. 
Of course, computing the roto-translation requires trigonometric functions, while all other computations involved are algebraic.

We test the same problem with different sets of parameters, changing the speed of the rotation and the position of the other triangle. The queries implemented with TIGHT take $27$ms, $133$ms and $2.5$s respectively, versus the $127$ms, $756$ms and $13.2$s of Filib++, for a speedup of approximately $5\times$.

\subsubsection{Intersection of two parametric tori}
\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{fig/torusInt.png}
	\caption{Test problem: surface-surface intersection (SSI) of two parametric tori of inner radius $0.3$ and outer radius $1$, each shifted by $\pm1.1$ along the $x$ axis.}
	\label{fig:tori}
\end{figure}
Computing the intersection of parametric surfaces, also known as surface-surface intersection (SSI), is an important operation in CAD.
In our example, we want to describe the intersection locus of two tori expressed parametrically.
Again, the parametric representation of each torus requires computing trigonometric functions.

SSI can be formulated in MiSo as a \textsc{Solve} problem, that is, the problem of covering the set of all solutions of a constraint system within a certain tolerance.
Being a conservative method, the algorithm returns a region that is larger than the true solution, but is guaranteed to contain every point of it.

Similarly to the previous example, the optimization variables are $\{\mathbf{u}, \mathbf{v}\}$, where $\mathbf{u}=(u_0, u_1)$ and $\mathbf{v}=(v_0, v_1)$ are the parametric coordinates of the two tori;
the constraints are the domain constraints $(u_0,u_1,v_0,v_1)\in[0,1]^4$ (implicit in MiSo), and the intersection constraint $d(x,y)<\epsilon$.
This formulation gives solutions in \emph{parameter} space rather than physical space. To be precise, this formulation solves a more general version of the problem: since the parameter space is 4-dimensional, the solution is a collection of 4D boxes that describe pairs of contacting regions, up to the specified tolerance.

In both cases, the solver performs 11105 iterations and found a solution composed of 6976 4D boxes. However, the result took $136$ms to compute with TIGHT and $2186$ms with Filib++, a speedup of about $16\times$.

\subsection{Pathological cases}
Not producing tight enough intervals can have unpredictable results for seemingly easy problems. We provide a very simple example where returning a slightly larger interval results in the program being unable to compute the result.

\begin{figure}
	\includegraphics[width=0.8\linewidth]{fig/example.png}
	\centering
	\caption{An example where tighter intervals of CR functions prevent errors: when the inputs to the problem are a few ULPs away from producing pathological situations, CR minimizes error and is often able to avoid failure. Moreover, its results are machine-independent; a non-CR implementation may complete successfully on one machine but fail on another.}
	\label{fig:tori}
\end{figure}
Suppose we have a function $f(x,y)$ defined on the plane that is inversely proportional to the distance of point $(x,y)$ to a circle centered in the origin with radius 5.
Thus, we are evaluating $f(x,y) = 1/(\sqrt{x^2 + y^2}-5)$.
This type of function resembles contact potentials used in IPC physical simulations \cite{Li2020IPC}.
We want to evaluate $f$ with interval arithmetic at point $P(3+10^{-15},4+10^{-15})$, so that $P$ lies outside the sphere. Remember that, because we are using interval arithmetic, we need not fear that adding a small value leads to cancellation for very small $\epsilon$: in those cases we simply get an interval that contains the true value.
We compute this function in three ways:
\begin{itemize}
	\item with TIGHT intervals, and using the function \texttt{hypot} to compute the Euclidean distance of $P$ from the origin (which is absent in Filib++);
	\item with TIGHT intervals, using only operators which are also supported by Filib++ (all algebraic in this case);
	\item with Filib++ intervals, using the same mode as the rest of the paper.
\end{itemize}
In the first two cases, the denominator is correctly computed as positive with TIGHT and the operation returns a real interval (albeit larger in the second case, due to multiple operations being involved).
When using Filib++, the square root produces an interval with lower bound equal to the radius, resulting in a division by zero.

While this example involves only a few operations, for more complex expressions, the propagation of error can be even more dramatic. 
While correct rounding does not eliminate the issue, it reduces propagation to a minimum and makes it predictable, since each operation can introduce at most 1 ULP of error on each side.

%\input{timetable}
